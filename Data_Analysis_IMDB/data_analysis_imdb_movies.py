# -*- coding: utf-8 -*-
"""Data_Analysis_IMDB_Movies.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bF2YqDSXtw49Or2xcNzoMsna_oJbpweL

# Introduction:
The data set I chose is Movie dataset

Here are some notes and comments about this datasets :
This data set contains information about 10,000 movies collected from The Movie Database (TMDb), including user ratings and revenue.

Certain columns, like ‘cast’ and ‘genres’, contain multiple values separated by pipe (|) characters.

There are some odd characters in the ‘cast’ column. Don’t worry about cleaning them. You can leave them as is.

The final two columns ending with “_adj” show the budget and revenue of the associated movie in terms of 2010 dollars, accounting for inflation over time.


# The questions about this dataset:

1. Does higher budget mean higher popularity ? Is there a coefficent relationship ?

2. Will the runtime affect the vote count and popularity?

3. Higher popularity means higher profits ?

4. What Features are Associate with Top 10 Revenue Movies ?

5. Which genres are most popular from year to year?
"""

# Commented out IPython magic to ensure Python compatibility.
# Import all the libraries which will be used later
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
# %matplotlib inline

"""# Data Wrangling:
Get familiar with the data types, data structure. I did delete the duplicates and unuseful columns like imdb_id,homepage etc.

When handling the missing data. I use two ways: for all the missing data with data type object, i fill the null with string
"missing". For budget, datatype integer,I fill 0 with np.NAN.

"""

# load in data and print out the head
df=pd.read_csv('tmdb-movies.csv')
df.head()

# check the rows and columns of this dataset
df.shape

# check datatypes to see if there are some wrongly categorized types
df.dtypes

# check each columns number of unique values
df.nunique()

# statistic values for this data
df.describe()

df.info()

df.isnull().sum()

# drop unuseful columns
df.drop(['id','imdb_id', 'homepage','overview'],axis=1,inplace=True)  # do not forget inplace

# Ways to handle missing data
# For all missing data with object as datatype , I fill in with string "missing"
df['cast'].fillna('missing',inplace=True )
df['director'].fillna('missing',inplace=True)
df['tagline'].fillna('missing',inplace=True)
df['keywords'].fillna('missing',inplace=True)
df['genres'].fillna('missing',inplace=True)
df['production_companies'].fillna('missing',inplace=True)
df['budget'] = df['budget'].replace(0, np.NAN)
# although there is no null in budget, but we would find there is a problem when we calculate df['budget'].median()
# Will deal with all the 0 value in budget later.

# confirm the data
df.isnull().sum()

# check if there are some duplicates
df.duplicated().sum()

# drop the duplicates
df.drop_duplicates(inplace=True)     # do not forget inplace = True
# confirm again
df.duplicated().sum()

# visulize each variables
df.hist(figsize=(15,15));

"""# Exploration with Visuals and Conclusions
Question 1. Does higher budget mean higher popularity ? Is there a coefficent relationship ?
"""

# plot the relation between budget and popularity
x = df['budget']
y = df['popularity']

plt.scatter(x,y)
plt.title('Average Popularity by Different budget',fontsize=12)
plt.xlabel('budgete',fontsize=10)
plt.ylabel('popularity',fontsize=10)

"""We can not see very strong relatioship between the budget and the popularity from above plot.
Let's try to compare the data in another way: create two groups based on median value of budget

"""

# based on median budget value to divide the budget into two groups : low and high
m = df['budget'].median()
low_budg =  df.query('budget < {}'.format(m))
high_budg =  df.query('budget >= {}'.format(m))

# check low budget and high budget mean values respecively
mean_popularity_of_low_budget = low_budg['popularity'].mean()
mean_popularity_of_high_budget = high_budg['popularity'].mean()

# create a bar chart with the values we get above
locations = [1,2]
heights = [mean_popularity_of_low_budget , mean_popularity_of_high_budget]
labels=['low','high']
plt.bar(locations, heights, tick_label = labels)
plt.title('Average Popularity by Different Budget')
plt.xlabel('Budgets')
plt.ylabel('Average Popularity')

increase_percentage = (mean_popularity_of_high_budget - mean_popularity_of_low_budget) / mean_popularity_of_high_budget * 100
increase_percentage

"""Conlcusion for Q1:
Through this bar plot, we can clearly see that high budget movies are more likely to have higher popularity.
We can make this conclusion that higeher budget movies gains more than 50% higher popularity than low budget movies.

Q2: What length will receive the highest popularity?
"""

# here I will create 3 groups with query().  <60 min: short   , 60 min <=  <= - 120 min: medium ,  >120 min: long
short =  df.query('runtime < {}'.format(100))
medium =  df.query('runtime < {}'.format(200))
long = df.query('runtime > {}'.format(200))

# check mean popularity of different movie lengths
mean_popularity_of_short = short['popularity'].mean()
mean_popularity_of_medium = medium['popularity'].mean()
mean_popularity_of_long = long['popularity'].mean()

locations = [1,2,3]
heights = [mean_popularity_of_short, mean_popularity_of_medium, mean_popularity_of_long]
labels=['low','medium','high']
plt.bar(locations, heights, tick_label = labels)
plt.title('Average Popularity by Different Runtime')
plt.xlabel('Runtime')
plt.ylabel('Average Popularity')

"""The movies should not be too long or too short. Medium length is better to gain higher popularity.
But above bar chart is hard to tell the best length of runtime. Scatter plot may be a better choice.
"""

# plot the relation between runtime and popularity
x = df['runtime']
y = df['popularity']

plt.scatter(x,y)

plt.title('Average Popularity by Different Runtime',fontsize=12)
plt.xlabel('runtime',fontsize=10)
plt.ylabel('popularity',fontsize=10)

"""Conclusion Q2:    
Combine two plots above, we can not simply say , the longer runtime, the more popular the movies are.  
If the movies are within 200 minutes,it will be more popular. Once the movies run over 200 minutes, it's hard for them to gain high popularity

Q3 : Higher popularity means higher profits ?
"""

# create a new column called profit. profit = Revenue - budget
df['profit'] = df['revenue'] - df['budget']
df['profit'].head(20)
df.head()

# we need to get the mean of popularity
m_popularity = df['popularity'].median()
lower_popularity =  df.query('popularity < {}'.format(m_popularity))
higher_popularity =  df.query('popularity >= {}'.format(m_popularity))

# average net profit for low_popularity and high_popularity
mean_profit_of_low_popularity = lower_popularity['profit'].mean()
mean_profit_of_high_popularity = higher_popularity['profit'].mean()
# df.head()

# create a bar chart with the values we get above
locations = [1,2]
heights = [mean_profit_of_low_popularity, mean_profit_of_high_popularity]
labels=['low','high']
plt.bar(locations, heights, tick_label = labels)
plt.title('Average profit by Different Popularity')
plt.xlabel('Popularity')
plt.ylabel('Average Profit')

"""Conclusion for Question 3: as we can see above, higher popularity does make much higher average profits.

4. What Features are Associate with Top 10 Revenue Movies ?
"""

top10_revenue = df.nlargest(10,'revenue')
top10_revenue.hist(figsize=(12,12))

"""Conclusion for question 4:

There are some characteristics we can conclude from the top 10 movies. Runtime ranges from 100 mins to 200 mins. The released year are between 1995 to 2015.

5. Which genres are most popular from year to year?
"""

#The following function can give all the counts for per category
def extract_data(column_name):
    data = df[column_name].str.cat(sep = '|') # put all the genres into a long string
    # Create pandas series and store the values separately
    data = pd.Series(data.split('|'))   # split the genres by |
    # Display value count in descending order
    count = data.value_counts(ascending = False) # count the occurrence of each genres
    return count

# use the function created above to split genres and count the occurrence of each one
genre_count = extract_data('genres')

#create a separate dataframe to plot
df_genre_counts = pd.DataFrame({'genres': genre_count.index, 'count': genre_count.values })
#df_genre_counts

f, ax = plt.subplots(figsize=(23, 9))
# use the dataframe just created as the input data
sns.barplot(x = 'count', y = 'genres', data=df_genre_counts) # how to get the data is the key
ax.set_title(' occurences per genre ')
ax.set_xlabel('occurrences')
ax.set_ylabel('genres')
plt.show()

director_count = extract_data('director')
director_count

movie_count = df['release_year'].value_counts()
# movie_count.plot(xlabel='year',ylabel='number of movies',title='Number of Movies Released Each Year')
fig = plt.figure()
plt.plot(movie_count)
fig.suptitle('Number of Movies Released Each Year',fontsize=20)
plt.xlabel('year',fontsize=18)
plt.ylabel('number of movies',fontsize=18)

"""Throught above two plots, we can see The top 5 genres are Drama, Comedy, Action, Horror and Adventrue
The number of movies increased along the time.
"""

# The following is a really comprehensive plot. It shows the revenue and budget for each genre type per year
# genres are so specific, I will just take the first genre for each movie instead of the genre combination
df['genre'] =  df['genres'].apply(lambda x: x.split('|')[0])

# plot all the genre types for each year with the budget and revenue
# The error was occuring because the groupby.mean() function attempts to find the mean of all columns,
# including non-numeric columns. We select only numeric features for calculating the mean.
genre_year = df.groupby(['genre', 'release_year'])[['budget','revenue']].mean().sort_index() # Only include 'budget', 'revenue'
df_gyBudget = genre_year.pivot_table(index=['genre'], columns=['release_year'], values='budget', aggfunc=np.mean)
df_gyBudget = genre_year.pivot_table(index=['genre'], columns=['release_year'], values='budget', aggfunc=np.mean)


df_gyGross = genre_year.pivot_table(index=['genre'], columns=['release_year'], values='revenue', aggfunc=np.mean)
f, [axA, axB] = plt.subplots(figsize=(40, 20), nrows=2)
cmap = sns.cubehelix_palette(start=1.5, rot=1.5, as_cmap=True)
sns.heatmap(df_gyBudget, xticklabels=3, cmap=cmap, linewidths=0.05, ax=axA)
sns.heatmap(df_gyGross, xticklabels=3, cmap=cmap, linewidths=0.05, ax=axB)
axA.set_title('budget x genre x year')
axA.set_xlabel('release_years')
axA.set_ylabel('genres')


axB.set_title('revenue x genre x year')
axB.set_xlabel('release_years')
axB.set_ylabel('genres')
plt.show()

"""Conclusion for Question 5:  As the time goes, we have a wider range of movies and genres to choose from.  From 1984 to 2014, there are more and more high budget, high revenue movies. But compared to the budgets,

# Conclusion:

Based on the analysis I did above, we can make the following summarizations:
1. The quantity and range of movie gets larger.We have more choices to choose from as an audience.
2. We can not say high budget guarantees high popularity. But for movies with higher budgets do produce higher average popularity.
3. To produce a more popular movie, the runtime should be best around 150 mins; Drama, Comedy, Action, these genres would be preferable.

# Limitations:
"""

